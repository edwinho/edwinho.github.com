---
layout: post
title: "纹理"
category : lessons
tags : [OpenGL, game]
---


## 1、光栅化
　　光栅化阶段用于将投影到2D屏幕的图元转化为帧缓冲上一个个整数坐标位置上的片段，每个片段都会包含颜色，深度和模板值。因此光栅化分为两个步骤：首先要确定视窗上哪些整数位置的片段被图元覆盖，如图；其次是对图元进行插值计算出第个片段的颜色和深度。

![Rasterize](http://edwinho.github.io/images/lessons/Rasterize.png)

<!-- more -->

### 1.1多重采样

　　反锯齿，也称为抗锯齿或者边缘柔化，它是一种消除显示器输出的画面中图像边缘出现凹凸的技术。

　　在光栅化的过程中，由于屏幕是由离散的像素点组成的，在对图元采样的时候就可能丢失一部分信息，导致其边沿出现锯齿。在OpenGL ES中使用多重采样技术来解决这个问题，与单重采样不同的是，帧缓冲上每个像素不是来自单个片段中心位置的采样，而是基于附近多个位置的采样共同决定的一个颜色值。因此相对于单重采样，帧缓冲需要增加额外的多重采样缓冲区来存储这些额外采样点的颜色，深度和模板值。这样就使得图元边缘能够比较平滑的过渡，能够减少这种视觉上的瑕疵。

![Multi-sample](http://edwinho.github.io/images/lessons/Multi-sample.png)

### 1.2 纹理坐标

　　在OpenGL ES中，纹理坐标以纹理的左下角为坐标原点。纹理坐标有两种度量形式：一个顶点在纹理中的纹理坐标通常用(u,v)来表示，u和v的最大值分别是纹理的宽度和高度，它的值通常由客户端应用程序提供；而在片段着色器中使用的片段纹理坐标通常用(s,t)来表示，其取值范围为(0.0,0.0)到(1.0,1.0)之间，这个规化过程是在光栅化阶段完成的，如图，该纹理尺寸为(8.0,4.0)

![TextureCoordinates](http://edwinho.github.io/images/lessons/TextureCoordinates.png)

## 2、像素矩阵

　　像素矩阵是一个抽象的概念，它表示一个矩形区域的二维像素数组，它可以用来表示一个矩形区域的颜色，深度或者模版值，对应其数组的每个像素值分别表示颜色，深度和模板。

## 3、客户端图像格式

　　纹理的格式及数据类型，都是指纹理在GL服务端中的存储模式，在将纹理传输到GL服务端以片段着色器等使用的时候，必须指明纹理在GL服务端以怎样的方式存储。

　　为了保证实时的渲染性能，服务端的纹理通常是未压缩（压缩纹理除外）的，因为这样能保证最快的读取。而客户端的图像资源通常是压缩为PNG或者JPG格式，这将占用更少的磁盘空间。

　　因此，客户端在传输纹理的时候首先需要解压图像资源，转化为GL服务端支持的纹理格式，才能保证纹理的正确使用，这涉及到两方面的内容：客户端图像格式与服务端纹理格式的一一对应，以及客户端图像数据在各种格式之间的转换。

## 4、纹理对象和加载纹理

　　在绘图管线中，纹理主要在片段着色器中被使用。每一次绘制命令执行时，需要告诉OpenGL ES当前管线中使用的一个或者多个纹理，这涉及到创建纹理对象，绑定当前纹理对象以及加载纹理数据到OpenGL ES内存中等命令操作。

　　一个纹理对象是一个容器，它持有该纹理被使用时需要用到的所有数据，这些数据包括图像像素数据，过滤模式，扩展模式等。

　　纹理一旦被传输至GL服务端，它会一直驻留在GPU管理的内存中，因此应该留意那些不再被使用的纹理，应该及时地从GL内存中删除它们，以减少应用程序内存的占用。


## 5、纹理单元与多重纹理

　　OpenGL ES支持在一个绘图管线中使用多个纹理，这通常被用在3D法线贴图等场景，用来增强画面表现，或者你也可以在片段着色器中使用自己特定的算法。

　　OpenGL ES使用纹理单元来管理多个纹理的使用，每个人纹理对象都被放置到一个纹理单元中。

## 6、纹理缩放

　　纹理贴图将纹理的一部分区域映射到图元定义的缓冲区域，通常这会导致重新构建一张新的图像，因为图元会被执行缩小，放大和旋转等操作，所能通常纹理中的每个纹素到缓冲区的像素不是一一映射的。这个时候，如果纹理被放大，一个纹素可能映射到多个像素点；如果纹理被缩小，多个纹素被映射到同一个像素点。上述两种情况都会导致图像失真。

![TextureZoom](http://edwinho.github.io/images/lessons/TextureZoom.png)

### 6.1 纹理缩小

　　如果纹理缩小时，则多个纹素被映射到一个像素点，这个时候就会丢失一部分纹素，南昌丢失的纹素可能包含重要的颜色过渡信息，导致贴图出现失真。在游戏中通常表现为远景部分出现模糊。

![TextureNarrow](http://edwinho.github.io/images/lessons/TextureNarrow.png)

### 6.2 纹理放大

　　如果纹理被放大，一个纹素则会被用到多个像素点上去，这就可能会出现大块纯色的区域。

![textureMagnify](http://edwinho.github.io/images/lessons/textureMagnify.png)

## 7、多级纹理

　　尽管纹理过滤模式可以用来处理适当的纹理缩放，然而这远远不能满足图形应用程序的需求，其纹理可能会经过远大于2倍的缩放，这个时候仍然会出现失真；另一方面由于移动设备的分辨率差异很大，在不同的设备中使用同一个分辨率的资源也会导致其对纹理的缩放比较严重。

　　多级纹理通过产生一个图像金字塔来适配不同分辨率的缩放，由于每一级的纹理是被预先生成的，它只被执行一次，多级纹理甚至可以在资源中生成，所以并不会影响渲染性能。

![MipTexture](http://edwinho.github.io/images/lessons/MipTexture.png)

　　多级纹理是一种高效的纹理采样技术，它使得图形应用程序可能不通过增加几何级的复杂度来增加场景的视觉复杂度，并使用应用程序不依赖于图元操作就可以达到更真实的画面。

　　多级纹理的级数由原始纹理的尺寸决定，原始纹理从0级开始，每一级由上一级尺寸的1/2尺寸大小组成。所以理论上每级纹理中的每个纹素是由上级纹理附近4个纹素决定的，这可以实现更平滑的缩放。同时也可以大概推算，多级纹理会比原始纹理多占据大约1/3的内存空间。


## 8、纹理压缩

　　在3D图形程序中，纹理不仅占据了大量的应用程序资源内容，也占据了大量的内存使用，传统的压缩方案如JPG能够减少资源的大小，但并不能对内存有多大贡献，一个图形数据在被传输到OpenGL ES服务端内存时，都需要被转化为RGB或者RGBA未压缩的格式，这才能保证实时渲染的性能。

### 8.1 压缩纹理的特点

　　* 解压速度快
　　* 随机读取
　　* 压缩率和图像质量
　　* 编码速度

### 8.2 压缩纹理的实现

　　压缩纹理使用一个固定的压缩比率，它首先按照这个比率将纹理分成很多的像素块，每个像素块包含如2x2，4x4个像素，然后对每个像素块进行压缩。每个被压缩后的像素信息存储在一个像素集合中，而一个块索引图存储了每个像素块的索引位置，在读取的时候首先根据块索引找到像素块，然后解压该像素块读取偏移值的信息。这称作为基于块的压缩得法。

![CompressTexture](http://edwinho.github.io/images/lessons/CompressTexture.png)

　　* 将纹理坐标转化为块索引值，计算出块索引值，以及该坐标在该像素块内的偏移值
　　* 根据块索引值在像素集合中查找对应的像素块
　　* 在这一段像素块中查找纹理坐标的颜色值

　　通过对固定数量的像素块进行压缩，压缩纹理就能够更快速的读取，实际在操作的时候对于一个像素块的数据还可以根据实际情况进行缓存。这种快速解压的速度使得图形渲染管线可以不依赖于CPU的解压就可以实现实时渲染，将压缩纹理直接保存在GPU内存中，既减少了资源在磁盘的存储大小，也大大节省了内存占用，还湖海了纹理在传输过程中所占用的带宽。

## 9、纹理缓存管理

　　通常在游戏循环中应做一些逻辑计算，更新各种游戏对象的状态。为了不影响游戏循环，应该在进入场景的时候（或者其它一些异步的时间）预加载所有需要的资源文件，将它们缓存进来，并在适当的时候删除缓存以减少内存占用。然而每个资源对生命周期有不同的需要，例如：

　　* 有些资源在游戏开始的时候就需要载入，并且驻留在内存中直至整个游戏结束。比如每个场景通用的一些按钮等元素。
　　* 有些资源的生命周期对应特定的场景，例如关卡资源。
　　* 一些剧情或者过场动画类资源有生命周期则比较短暂，它们在使用之后立即被销毁。
　　* 还有其它一些资源则很难定义其生命周期，例如跑酷游戏中的资源跟玩家跑动的距离有关，这个时候则需要小心地动态预加载。

## 10、总结

　　纹理是游戏开发中的重点内容，并且纹理的重要性往往要在游戏后期才暴露出来，在早期程序和美术往往都会肆无忌惮地使用更多的纹理，更多的特效，动画，到后期临近发布才会突然面临内存、耗电等严重问题。

　　所以明确理解纹理相关的各个方面的细节，实现各个方面的优化，从而使游戏具有更好的性能和体验。
