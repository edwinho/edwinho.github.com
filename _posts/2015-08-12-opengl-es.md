---
layout: post
title: "OpenGL ES"
category : lessons
tags : [OpenGL, game]
---


　　大多数移动平台游戏引擎都采用OpenGL ES进行绘制。游戏引擎对开发者提供了一组UI元素，以及组织这些UI元素构成游戏场景的接口。在游戏引擎内部，则将这些UI元素转化为一系列OpenGL ES命令的调用，并在每一帧中将场景绘制到设备屏幕上。

<!-- more -->

## 1、OpenGL ES简介

　　OpenGL ES(OpenGL for Embedded System)是一套图形硬件的软件接口，它直接和GPU进行交互，我们可以创建实时的3D图形程序，如游戏，视频等。它是桌面版 OpenGL图形库的一个子集。主要应用在嵌入式和手持设备中，如智能手机，平板电脑。

　　应用程序通过一些图形库来使用 GPU 处理图形计算，如OpenGL，Direct X等。由于GPU的并行架构和计算能力，近年来人们也尝试将GPU用于日常并行计算，OpenCL 就是致力于这方面的一个库，它是由维护OpenGL ES的khronos组织负责开发与维护。 

　　目前 OpenGL ES 主要有 3 个大的版本，分别是 OpenGL ES 1.x，OpenGL ES 2.x以及 OpenGL ES 3.x。其中OpenGL ES 1.x 针对固定管线硬件，而OpenGL ES 2.0及以上针对可编程管线硬件。 主流的智能手机如 iPhone 和 Android 大多都支持OpenGL ES 2.0，因此大多数移动平台的游戏引擎主要都使用OpenGL ES 2.0 来绘制。苹果由 iPhone 5S已经开始支持 OpenGL ES 3.0，它在画面上有更优秀的表现力。

　　OpenGL ES的全部功能都集中在怎样将程序中定义的各种2D或3D的模型绘制到帧缓存中，或者从帧缓存中读取数据到程序中。

## 2、渲染管线
　　OpenGL ES 的主要作用是将 3D 场景绘制到 2D 的屏幕上， 在图形学中这通过一系列的渲染管线来完成， OpenGL ES API 就是用来向各个阶段提供一些数据和状态指令，以使渲染管线能够按照要求正确绘制出物体在屏幕上。

![rendering-pipeline](http://edwinho.github.io/images/lessons/rendering-pipeline.png)

　　左边的客户端程序通过调用 OpenGL ES 接口，将顶点，着色器程序，纹理，以及其他一些 GL 状态参数传入右边的 GL 服务端， 然后在客户端调用绘制命令的时候， GL 便会将输入的图元，逐一执行渲染管线的每个阶段，然后将每个像素的颜色值写入到帧缓冲中， 最后视窗系统就可以将帧缓冲中的颜色值显示在屏幕上。 此外，应用程序也可以从帧缓冲中读取数据到客户端。

　　在整个管线中，顶点着色器和片段着色器是可编程的部分，应用程序可以通过提供着色器程序在 GPU 中被作用于渲染管线。其他阶段则只能使用一些固定的 GL 命令来影响该阶段的执行。

### 2.1 顶点数组

　　OpenGL ES并不提供对3D模型的定义，在传入OpenGL ES之前应用程序应该首先将3D模型转换为一组图元的集合。每个模型是独立绘制的，修改其中一个模型的一些设置并不会影响其他模型。

![Vertices](http://edwinho.github.io/images/lessons/Vertices.png)

　　每个图元由一个或者多个顶点组成，每个顶点定义一个点，一条边的一端或者三角形的一个角。每个顶点关联一些数据，这些数据包括顶点坐标，颜色，法向量以及纹理坐标等。所有这些顶点相关的信息就构成顶点数组，这些数据首先被上传到 GL 服务端，然后就可以进行绘制。

　　OpenGL 中的命令总是按照它被接收到的顺序执行，这意味着一组图元必须被全部绘制完毕才会开始绘制下一组图元。同时也意味着程序对帧缓冲的像素读取的结果一定是该命令之前所有 OpenGL 命令执行的结果。

### 2.2 顶点着色器

　　顶点着色器对每个顶点执行一次运算，它可以使用顶点数据来计算该顶点的坐标，颜色，光照，纹理坐标等，在渲染管线中每个顶点都是独立地被执行。

　　在顶点着色器中最重要的任务是执行顶点坐标变换，应用程序中设置的图元顶点坐标通常是针对本地坐标系的。本地坐标系简化了程序中的坐标计算，但是GL并不识别本地坐标系，所以在顶点着色器中要对本地坐标执行模型视图变换，将本地坐标转化为裁剪坐标系的坐标值。

　　顶点着色器的另一个功能是向后面的片段着色器提供一组易变变量。易变变量会在图元装配阶段之后被执行插值计算，如果是单重采样，其插值点为片段的中心，如果多重采样，其插值点可能为多个采样片段中的任意一个位置。易变变量可以用来保存插值计算片段的颜色，纹理坐标等信息。

### 2.3 图元装配

　　在顶点着色器程序输出顶点坐标之后，各个顶点被按照绘制命令中的图元类型参数，以及顶点索引数组被组装成一个个图元。

![primitive-assembly](http://edwinho.github.io/images/lessons/primitive-assembly.png)

　　顶点数组首先通过 GL 命令输入到 GL 渲染管线中，此时顶点坐标位于应用程序的本地坐标系；在经过顶点着色器的计算之后，顶点坐标被转化到裁剪坐标系中，这通常通过向顶点着色器传入一个模型视图变换矩阵，然后在顶点着色器中执行坐标变换。

　　裁剪坐标系被定义在一个视锥体裁剪的空间里，视锥体是游戏场景的一个可视空间，它由6个裁剪平面构成，分别是：近平面，远平面，左平面，右平面，上平面和下平面。

　　视锥体在 3D 应用程序中通常表现为一个摄像机，其观察点为裁剪坐标系的原点，方向为穿过远近平面的中点。

![View-Volume](http://edwinho.github.io/images/lessons/View-Volume.png)

　　处于视锥体以外的图元将被丢弃，如果该图元与视锥体相交则会发生裁剪产生新的图元。值得注意的是透视裁剪是一个比较影响性能的过程，因为每个图元都需要和 6 个面进行相交计算，并产生新的图元。但是一般在x，y方向超出屏幕之外的，则无需产生新的图元，这些顶点能在视口变换的时候被更高效的丢弃。

　　经过视锥体裁剪之后的顶点坐标然后被经过透视分离投影到屏幕或者视口上,这称之为规则化的设备坐标系，这些坐标值的取值范围为[0,1]。

### 2.4 光栅化

　　通过图元装配，所有 3D 的图元已经被转化为屏幕上 2D 的图元。光栅化的主要作用是将2D图元转化为一系列的片段，并计算每个片段的位置。每个片段会执行一次片段着色器程序，在片段着色器中使用光栅化计算出的片段位置给每个片段着色，各个片段执行器的执行仍然是并行的。

![rasterization](http://edwinho.github.io/images/lessons/rasterization.png)

　　在光栅化之前，首先要判断图元是朝向观察者还是背离观察者，以决定是否需要丢弃图元，这可以通过 glFrontFace 命令来决定哪个方向为正，并通过 glCullFace来决定需要保留哪一面。这可以减少一些不必要的绘制，减少 GPU 的浪费。

　　在计算出每个片段的坐标值之后，片段着色器就能使用这个坐标值对该片段进行着色，这个片段为最终屏幕上一个像素点。此外，光栅化还需要计算那些在顶点着色器中定义的易变变量的插值，这些值最终被用在片段着色器中用来计算片段最终的颜色值，例如片段的纹理坐标，颜色等。

### 2.5 片段着色器

　　可编程的片段着色器是实现一些高级特效如纹理贴图，光照，环境光，阴影等功能的基础。片段着色器的主要作用是计算每一个片段的颜色值(或者丢弃该片段)。

　　在片段着色器之前的阶段，渲染管线都只是在和顶点，图元打交道。在 3D 图形程序开发中，贴图是最重要的部分，程序可以通过 GL 命令上传纹理数据至GL内存中，这些纹理可以被片段着色器使用。

　　片段着色器可以根据顶点着色器输出的顶点纹理坐标对纹理进行采样，以计算该片段的颜色值，这些值最后被写入到帧缓冲。

　　由于在实际贴图过程中可能会涉及放大和缩小，以及纹理坐标超出(0,0)和(1,1)之间，为了处理这些问题一般在绑定纹理的时候可以通过 glTexParameter 来设置纹理相关的一些处理模式，例如多级纹理。

　　另外，片段着色器也是执行光照等高级特效的地方，比如可以传给片段着色器一个光源位置和光源颜色，可以根据一定的公式计算出一个新的颜色值，这样就可以实现光照特效。

### 2.6 片段测试

　　片段着色器输出的颜色值，还要经过几个阶段的片段操作，这些操作可能会修改片段的颜色值，或者丢弃该片段，最终的片段颜色值才会被写入到帧缓冲中。

![fragment-operations](http://edwinho.github.io/images/lessons/fragment-operations.png)

　　像素所有权测试用来判断帧缓冲区中该位置的像素是否属于当前 OpenGL ES，例如在窗口系统中该位置可能会被其他应用程序窗口遮挡，此时该像素则不会被显示。

　　在片段测试之后，片段要么被丢弃，要么每个片段对应的颜色，深度，模板值会被写入帧缓冲区，最终呈现在设备屏幕上。帧缓冲区中的颜色值也可以被读回到客户端应用程序中，这样可以实现绘制到纹理的效果。

## 3、渲染管线的并行计算

　　OpenGL ES总是按顺序执行命令，意味着每个物体必须全部绘制完成才会开始绘制下一个物体，这样能保证不管什么情况屏幕上显示的是正确的图像。然而在每个管道的各个阶段，所有处理则是并行的，这样保证了实时显示的性能。

　　多个顶点，多个图元，多个片段都是独立并行处理，这大大提高了渲染性能。

![parallel](http://edwinho.github.io/images/lessons/parallel.png)

　　正因为每个顶点，图元及片段被并行处理，所以它们没有任何状态，例如在顶点着色器程序中你不知道下一个要处理的顶点是什么，所有顶点着色器和片段着色器中的变量都必须通过程序中获取, 或者通过光栅化阶段插值计算(varying)。

　　OpenGL ES 是一个状态机，管道中的很多操作都需要依赖于当前特定状态值，例如是否执行深度测试。这些状态会影响管道中所有顶点，图元，片段的执行，这样才能保证并行性计算，实现更高效率的绘制。

## 4、帧缓冲

　　OpenGL ES 渲染管道最终的目的地是将每个像素点的颜色，深度，模板等数据输送到帧缓冲(Framebuffer)。

　　帧缓冲存储着 OpenGL ES 绘制每个像素点最终的所有信息：颜色，深度和模板值。一个帧缓冲上有三个对应的附加点，它们是一个逻辑缓冲区，分别用来存储所有像素的颜色，深度和模板数据。。

　　帧缓冲通常由视窗系统提供，但也可以通过应用程序创建，应用程序可以将不同的内容绘制到不同的帧缓冲。在多个帧缓冲之间切换不需要切换 OpenGL ES上下文，通常使用此方式来高效地将内容绘制到纹理。

![Framebuffer](http://edwinho.github.io/images/lessons/Framebuffer.png)

　　只有将内容绘制到视窗体提供的帧缓冲，才能将内容输出到显示设备。视图系统提供的帧缓冲的颜色缓冲区通常由两个缓冲对象组成，一个前端缓冲，一个后端缓冲。
