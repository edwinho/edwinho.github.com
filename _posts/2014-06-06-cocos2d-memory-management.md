---
layout: post
title: "Cocos2d-x内存管理机制"
category : game
tags : [cocos2dx, C++]
---

[TOC]

　　Cocos2d-x的内存管理机制实际上来源于Objective-C，这套机制几乎贯穿Cocos2d-x引擎中所有对动态分配内存的管理，它使管理动态分配到堆上的对象的工作更加简单和高效。但是，它独特的工作机制也使一些开发者，尤其是不熟悉Objective-C的开发者对其形成一些“误解”。

<!-- more -->

## 1、C++显式内存管理

　　C++使用new关键字在运行时给一个对象动态分配内存，并返回堆上内存的地址供应用程序访问，被动态分配的内存需要在对象不再被使用时通过delete运算符将其内存释放，归还给内存池。

　　显式的内存内存管理在性能上有一定优势，但是极易出错。一方面，直接访问内存地址提高了应用程序的性能及内存使用的灵活性；另一方面，我们总是无法通过人的思维去保证一个逻辑的正确，由于程序没有正确地分配与释放而造成的野指针、重复释放、内存泄漏等问题又严重影响着应用程序的稳定性。 

* 野指针：指针指向的内存单元已经被释放，但是其它指针可能还指向它，这些内存可能已经被重新分配给其他对象，从而导致无法预测的结果。
* 重复释放：重复释放一个已经被释放的内存单元，或者释放一个野指针（也是重复释放）都会导致C++运行时错误。
* 内存泄漏：不再被使用的内存单元如果不被释放，就会一直占用内存单元，如果这些操作不断重复，就会导致内存占用不断增加。在游戏中，内存泄漏引发的问题尤其严重，因为可能每一帧都在创建一个永远不会被回收的对象。

## 2、C++11中的智能指针
　　根据分配内存的方法，C++有3种管理数据内存的方法，分别是自动存储、静态存储和动态存储。其中，静态存储用于存储一些在整个应用程序执行期间都存在的静态变量，动态存储用于存储通过new关键字分配的内存单元。

　　而对于在函数内部定义的常规变量，则使用自动存储空间，其对应的变量称为自动变量。自动变量在所属的函数被调用时自动产生，在该函数结束时消亡。实际上，自动变量是一个局部变量，其作用域包含它的代码块所对应的作用域。自动变量通常存储在栈上，这意味着进入代码块时，其中的变量将依次加入栈中，而在离开该代码块时，按与加入时相反的顺序释放这些变量。所有自动变量的内存总是能够被正确的释放。

　　由于自动变量通常不会导致内存问题，所以智能指针试图通过将一个动态分配的内存单元与一个自动变量关联，让这个自动变量在离开代码块并被自动释放的时候释放其管理指针的内存单元，这使程序员不再不需要显式地调用delete运算符就可以很好地管理动态分配的内存。

　　C++11使用3种不同的智能指针，分别是unique\_ptr、shared\_ptr和weak\_ptr，都属于模板类型，可以通过如下的方式使用它们。
```
 int main() {
      unique_ptr<int> p1 (new int(11));
      shared_ptr<int> p2 (new int(22));
      weak_ptr<int> p3 = p2;
 }
```

　　每个智能指针都重载了“\*”运算符，我们可以使用“\*p1”访问所分配的堆内存。智能指针在析构或者调用reset成员的时候，都可能释放其所拥有的堆内存。三者之间的区别如下。

* unipue\_ptr指针不能与其它智能指针共享所指对象的内存，如将“p1”赋值给“p4”（`uniqui_ptr<int>p4 = p1;`）将导致编译错误。但是，可以通过标准库的move函数来转移unique\_ptr指针对象的“所有权”，一旦转移成功，原来的unique\_ptr指针就失去了对对象内存的所有权，再使用该指针会导致运行时错误。
* 多个shared\_ptr指针可以共享同一堆分配对象的内存，它在实现上采用引用计数，即使一个shared\_ptr指针放弃了所有权（调用了reset成员或离开其作用域），也不会影响其它智能指针对象。只有所有引用计数归零的时候，才会真正释放所占有的堆内存。
* weak\_ptr指针可以用来指向shared\_ptr指针分配的对象内存，但不拥有该内存，我们可以使用其lock成员来访问其指向内存的一个shared\_ptr对象，当其所指向的内存无效时，返回指针空值（nullptr）。weak_ptr指针通常可以用来验证shared\_ptr指针的有效性。

