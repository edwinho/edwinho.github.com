---
layout: post
title: "Cocos2d-x内存管理机制"
category : game
tags : [cocos2dx, C++]
---

[TOC]

　　Cocos2d-x的内存管理机制实际上来源于Objective-C，这套机制几乎贯穿Cocos2d-x引擎中所有对动态分配内存的管理，它使管理动态分配到堆上的对象的工作更加简单和高效。但是，它独特的工作机制也使一些开发者，尤其是不熟悉Objective-C的开发者对其形成一些“误解”。

<!-- more -->

### 1、C++显式内存管理

　　C++使用new关键字在运行时给一个对象动态分配内存，并返回堆上内存的地址供应用程序访问，被动态分配的内存需要在对象不再被使用时通过delete运算符将其内存释放，归还给内存池。

　　显式的内存内存管理在性能上有一定优势，但是极易出错。一方面，直接访问内存地址提高了应用程序的性能及内存使用的灵活性；另一方面，我们总是无法通过人的思维去保证一个逻辑的正确，由于程序没有正确地分配与释放而造成的野指针、重复释放、内存泄漏等问题又严重影响着应用程序的稳定性。 

* 野指针：指针指向的内存单元已经被释放，但是其它指针可能还指向它，这些内存可能已经被重新分配给其他对象，从而导致无法预测的结果。
* 重复释放：重复释放一个已经被释放的内存单元，或者释放一个野指针（也是重复释放）都会导致C++运行时错误。
* 内存泄漏：不再被使用的内存单元如果不被释放，就会一直占用内存单元，如果这些操作不断重复，就会导致内存占用不断增加。在游戏中，内存泄漏引发的问题尤其严重，因为可能每一帧都在创建一个永远不会被回收的对象。

### 2、C++11中的智能指针
　　根据分配内存的方法，C++有3种管理数据内存的方法，分别是自动存储、静态存储和动态存储。其中，静态存储用于存储一些在整个应用程序执行期间都存在的静态变量，动态存储用于存储通过new关键字分配的内存单元。

　　而对于在函数内部定义的常规变量，则使用自动存储空间，其对应的变量称为自动变量。自动变量在所属的函数被调用时自动产生，在该函数结束时消亡。实际上，自动变量是一个局部变量，其作用域包含它的代码块所对应的作用域。自动变量通常存储在栈上，这意味着进入代码块时，其中的变量将依次加入栈中，而在离开该代码块时，按与加入时相反的顺序释放这些变量。所有自动变量的内存总是能够被正确的释放。

　　由于自动变量通常不会导致内存问题，所以智能指针试图通过将一个动态分配的内存单元与一个自动变量关联，让这个自动变量在离开代码块并被自动释放的时候释放其管理指针的内存单元，这使程序员不再不需要显式地调用delete运算符就可以很好地管理动态分配的内存。

　　C++11使用3种不同的智能指针，分别是unique\_ptr、shared\_ptr和weak\_ptr，都属于模板类型，可以通过如下的方式使用它们。

```C++
int main() {
	unique_ptr<int> p1 (new int(11));
	shared_ptr<int> p2 (new int(22));
	weak_ptr<int> p3 = p2;
}
```

　　每个智能指针都重载了“\*”运算符，我们可以使用“\*p1”访问所分配的堆内存。智能指针在析构或者调用reset成员的时候，都可能释放其所拥有的堆内存。三者之间的区别如下。

* unipue\_ptr指针不能与其它智能指针共享所指对象的内存，如将“p1”赋值给“p4”（`uniqui_ptr<int>p4 = p1;`）将导致编译错误。但是，可以通过标准库的move函数来转移unique\_ptr指针对象的“所有权”，一旦转移成功，原来的unique\_ptr指针就失去了对对象内存的所有权，再使用该指针会导致运行时错误。
* 多个shared\_ptr指针可以共享同一堆分配对象的内存，它在实现上采用引用计数，即使一个shared\_ptr指针放弃了所有权（调用了reset成员或离开其作用域），也不会影响其它智能指针对象。只有所有引用计数归零的时候，才会真正释放所占有的堆内存。
* weak\_ptr指针可以用来指向shared\_ptr指针分配的对象内存，但不拥有该内存，我们可以使用其lock成员来访问其指向内存的一个shared\_ptr对象，当其所指向的内存无效时，返回指针空值（nullptr）。weak_ptr指针通常可以用来验证shared\_ptr指针的有效性。

### 3、为什么不使用智能指针
　　看起来，shared\_ptr是一个完美的内存管理方案，然而，实际上至少有以下两个原因使Cocos2d-x不应该使用智能指针。

　　第一，智能指针有比较大的性能损失。shared\_ptr为了保证线程安全，必须使用一定开工的互斥锁来保证所有线程访问时其引用计数正确。这种性能损失对一般的应用程序而言是没有问题的，而对游戏这种实时性要求非常高的应用程序却是不可授受的，游戏需要一种更简单的内存管理模型。

　　第二，虽然智能指针能帮助程序员进行有效的堆内存管理，但它仍然需要程序员显式地声明智能指针。例如，创建一个Node的代码需要这样写。

```C++
	shared_ptr<Node*> node(new Node());
```

　　另外，在需要引用的地方，一般应该使用weak\_ptr指针，否则在Node被移除的时候还要手动减持shared\_ptr指针的引用计数，示例如下。

```C++
    weak_ptr<Node*> refNode = node;
```

　　这些额外的约束让智能指针使用起来很不自然。这种用一种约束的方式来避免逻辑错误的方法虽然可取，却不是一种优雅的方式。开发者每天都要而对大量的代码，他们需要更自然的内存管理方式，就像语言自身的特性一样，甚至几乎察觉不到其背后的机制。

### 4、垃圾回收机制
　　垃圾回收器将之前使用过、现在不再使用或者没有任何指针再指向的内存空间称为“垃圾”，将这些“垃圾”收集起来以便再次利用的机制称为“垃圾回收”。垃圾回收机制在1959年前后由约翰·麦肯锡（John MaCarthy）为Lisp语言发明，在编程语言发展的过程中，垃圾回收机制的堆内存管理也得到了很大的发展。如今流行的一些语言，如Java、C#、Ruby、PHP、Perl等，都支持垃圾回收机制。

　　垃圾回收主要有如下两种方式。

* 基于引用计数：引用计数使用系统记录的一个对象被引用的次数，当对象被引用的次数变为零时，该对象即被视作为垃圾而被回收。这种算法的优点是实现方式比较简单。
* 基于跟踪处理：先产生跟踪对象的关系图，再进行垃圾回收。其算法是首先将程序中正在使用的对象视为根对象，从根对象开始查找它们所引用的堆空间，并在这些堆空间上做标记。做完标记之后，所有未被标记的对象即被视作垃圾，会在第二阶段被清理。在第二阶段可以使用不同的方式进行清理，直接清理可能会产生大量的内存碎片。清理方法是对正在使用的对象进行移动或者复制，从而减少内存碎片的产生。

　　不管采用哪种方式，垃圾回收机制都可以使内存管理变得更自然，更重要的是，程序员几乎不用为此做任何被约束的事情。


### 5、Cocos2d-x内存管理机制
　　垃圾回收机制通常需要语言级的实现。C++目前尚未提供完整的垃圾回收机制，Cocos2d-x中的内存管理机制可以看成基于智能指针的一个变体，但它同时使程序员可以像使用垃圾回收机制那样不需要声明智能指针。
　　**1.引用计数**
　　Cocos2d-x中的所有对象几乎都继承自Ref基类。Ref基类主要的职责就是对对象进行引用计数管理，示例如下。

```C++
	class CC_DLL Ref
	{
	public:
		void retain();
		void release();
		Ref* autorelease();
		unsigned int getReferenceCount() const;

	protected:
		Ref();

	protected:
		// count of references
		unsigned int  _referenceCount;
		friend class AutoreleasePool;
	};
```

　　当一个对象使用由new运算符分配的内存时，其引用计数为1，调用retain()方法会增加其引用计数，调用release()方法则会减少其引用计数，release()方法会在其引用计数为零时自动调用delete运算符删除对象并释放内存。
　　除此之外，retain()方法和release方法没有做任何特别的事情，它们只是帮助我们记录一个对象被引用的次数。实际上，在程序中很少直接单独使用retain()方法和release()方法来管理内存，因为最重要的还是要在设计的时候就明确它们应该在哪个地方被释放，大多数引用只是一种弱引用关系，使用retain()方法和release()方法反而会增加复杂性。
　　来看一下在仅有引用计数的情况下应该怎样管理UI元素，示例如下。

```c++
	auto node = new Node();          // 引用计数为1
	addChild(node);                  // 引用计数为2
	node->removeFromParent();        // 引用计数为1
	node->release();                 // 引用计数为0
```

　　显然，这不是我们想要的结果。如果忘记调用release()方法就会导致内存泄漏。